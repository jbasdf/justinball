{"version":3,"sources":["webpack:///path---omniauth-devise-and-facebook-client-login-dont-play-nice-35cc1a60309d4d6e1de7.js","webpack:///./.cache/json/omniauth-devise-and-facebook-client-login-dont-play-nice.json"],"names":["webpackJsonp","1343","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","imageUrl","image","pathContext","path"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,cAAAC,OAAA,gBAA8CC,gBAAmBC,GAAA,8JAAAC,KAAA,2iQAAo3PC,aAAgXL,MAAA,6DAAAM,KAAA,oBAAAC,SAAA,KAAAC,MAAA,QAA+HC,aAAgBC,KAAA","file":"path---omniauth-devise-and-facebook-client-login-dont-play-nice-35cc1a60309d4d6e1de7.js","sourcesContent":["webpackJsonp([31230866529606],{\n\n/***/ 1343:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Justin Ball\",\"author\":\"Justin Ball\"}},\"markdownRemark\":{\"id\":\"/Users/jbasdf/projects/justinball/src/posts/2014-02-27-omniauth-devise-and-facebook-client-login-dont-play-nice/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>I've had to use Facebook login inside an iframe twice now. Combine <a href=\\\"https://github.com/plataformatec/devise\\\">Devise</a>\\nwith <a href=\\\"https://github.com/intridea/omniauth\\\">omniauth</a> and <a href=\\\"https://github.com/mkdynamic/omniauth-facebook\\\">omniauth-facebook</a> and you have a\\npretty great user authentication system. Now try to login via Facebook inside an iframe and nothing will happen. If you check your Javascript console you'll see a error\\nthat looks something like this:</p>\\n<blockquote>\\n  Refused to display 'https://www.facebook.com/login.php?skip_api_login=1&api_key=asdfasdf%23_%3D_&display=page' in a frame because it set 'X-Frame-Options' to 'DENY'.\\n</blockquote>\\n<p>Facebook won't render their UI inside of an iframe. A lot of sites do that these days. However, you can use the Facebook Javascript client and everything will\\njust work - sort of. Omniauth-facebook documents a <a href=\\\"https://github.com/mkdynamic/omniauth-facebook#client-side-flow\\\">Client side flow</a> which looks like the\\nperfect solution to our problem but as I've learned it's not rainbows and unicorns.</p>\\n<p>If you do follow the advice provided by the documentation you'll spend hours saying things to your computer that you will regret. You'll feel depressed because you\\nfollowed the documentation and yet request.env[\\\"omniauth.auth\\\"] will be nil no mater what you do.</p>\\n<p>There are two github threads related to this problem: <a href=\\\"https://github.com/mkdynamic/omniauth-facebook/issues/73\\\">https://github.com/mkdynamic/omniauth-facebook/issues/73</a>\\nand <a href=\\\"https://github.com/intridea/omniauth-oauth2/issues/31\\\">https://github.com/intridea/omniauth-oauth2/issues/31</a> and a number of Stack Overflow questions\\n<a href=\\\"http://stackoverflow.com/questions/10320320/facebook-javascript-sdk-and-omniauth/22082218#22082218\\\">including this one that I tried to answer</a> since way\\nmore people will find it on Stack Overflow than here.</p>\\n<h3>Some Tips Before We Step In the Deep Stuff</h3>\\n<p>If you're debugging through this problem the first thing you might try is using a domain like lvh.me to access your local machine (it resolves to 127.0.0.1). Chrome\\nhas issues writing to localhost and it's possible that the Facebook cookie you need is not being properly written.</p>\\n<p>Right now would be a good time to check to make sure you don't accidently do the Oauth dance twice. This bit me. We have a link on the page with the id 'facebook_connect'.\\nIt just so happens that the href of that link is '/users/auth/facebook' which means it will initiate the Oauth dance using Omniauth. We only want to talk to Facebook once\\nso be sure to call e.preventDefault() or else you will keep wondering why you get two server calls:</p>\\n<pre><code class=\\\"javascript\\\">\\n$('#facebook_connect').on('click', function(e){\\n  e.preventDefault(); // Stop the request right here.\\n  Facebook.login();\\n});\\n</pre></code>\\n<p>The next thing you'll want to verify is that you are telling Facebook to write a cookie.</p>\\n<pre><code class=\\\"javascript\\\">\\nFB.init({\\n  appId      : GLOBAL_SETTINGS.FBappId,\\n  status     : false, // don't check login status\\n  cookie     : true, // enable cookies to allow the server to access the session\\n  xfbml      : true  // parse XFBML\\n});\\n</pre></code>\\n<h3>Before We Start</h3>\\nIf you just want to see how to do the Facebook OAuth dance client side below is the code I use to handle Facebook logins:\\n<script src=\\\"https://gist.github.com/jbasdf/9262863.js\\\"></script>\\n<h3>The Problem</h3>\\nI'm guessing you're still running into problems. The source of the issue is the callback_phase method inside the omniauth-oauth2 gem:\\n<pre><code class=\\\"ruby\\\">\\nif !options.provider_ignores_state && (request.params['state'].to_s.empty? || request.params['state'] != session.delete('omniauth.state'))\\n   raise CallbackError.new(nil, :csrf_detected)\\nend\\n</pre></code>\\n<p>request.params['state'] and session['omniauth.state'] are both nil so the condition fails and a CallbackError exception is raised. This is due\\nto the fact that we initiated the Facebook OAuth dance via FB.Login rather than using Omniauth to initiate the dance. Omniauth sets a state variable in the session\\nand then passes that as a state variable to Facebook like this:</p>\\n<pre><code class=\\\"ruby\\\">\\nsession['omniauth.state'] = SecureRandom.hex(24)\\n</pre></code>\\n<p>You can see above that the omniauth-oauth2 gem checks to make sure the state passed back from Facebook matches the one it saved into the session before\\nthe dance started.</p>\\n<p>Sucks for the client side process.</p>\\n<h3>Solution 1 - Cheap and Easy but Not So Secure</h3>\\nOne solution is to set provider_ignores_state to true which circumvents the condition:\\n<pre><code class=\\\"ruby\\\">\\nconfig.omniauth :facebook, ENV['FACEBOOK_APP_ID'], ENV['FACEBOOK_APP_SECRET'], {\\n  strategy_class: OmniAuth::Strategies::Facebook,\\n  provider_ignores_state: true,\\n}\\n</pre></code>\\n<p>That solution isn't especially secure since it can leave you open to csrf attacks.</p>\\n<h3>Solution 2 - More Code Solves Everything</h3>\\nMore code isn't usually a great way to solve your problems, but you can always create your own handler and parse the Facebook cookies yourself like this:\\n<pre><code class=\\\"ruby\\\">\\ndef handle_facebook_connect\\n    @provider = 'facebook'\\n    @oauth = Koala::Facebook::OAuth.new(ENV[\\\"FACEBOOK_ID\\\"], ENV[\\\"FACEBOOK_SECRET\\\"])\\n    auth = @oauth.get_user_info_from_cookies(cookies)\\n\\n    # Get an extended access token\\n    new_auth = @oauth.exchange_access_token_info(auth['access_token'])\\n    auth['access_token'] = new_auth[\\\"access_token\\\"]\\n\\n    # Use the auth object to setup or recover your user. The following is\\n    # and example of how you might handle the response but your needs and application structure will vary.\\n    if authentication = Authentication.where(:uid => auth['user_id'], :provider => @provider).first\\n      user = authentication.user\\n      sign_in(user, :event => :authentication)\\n    end\\n\\n    # Redirect or respond with json\\n    respond_to do |format|\\n      format.html { redirect_to user }\\n      format.json { render json: user }\\n    end\\nend\\n</pre></code>\\n<p>Then you'll need to redirect to the 'handle<em>facebook</em>connect' method when you receive a connected response:</p>\\n<pre><code class=\\\"javascript\\\">\\nFB.Event.subscribe('auth.authResponseChange', function(response) {\\n  if(response.status === 'connected'){\\n    if(response.authResponse){\\n\\n      // Redirect to our new handler\\n      window.location = '/handle_facebook_connect';\\n\\n    }\\n  } else if (response.status === 'not_authorized'){\\n    Facebook.message(Facebook.authorize_message);\\n  } else {\\n    FB.login();\\n  }\\n });\\n\\n</pre></code>\\n<h3>Solution 3 - Fake It</h3>\\nIf nothing so far brings joy to your heart then we can also simulate what omniauth does with the state variable.\\n<p>I create a helper method that can be called where ever we need to use the client side Facebook login. We also have a global settings object\\nthat can be accessed by our Javascript on the client. Calling 'add_state' generates a secure value and passes it to the client.</p>\\n<pre><code class=\\\"ruby\\\">\\ndef global_settings\\n    settings = {\\n      FBappId: ENV[\\\"FACEBOOK_ID\\\"],\\n      application_name: ENV[\\\"APPLICATION_NAME\\\"]\\n    }\\n    settings[:state] = session['omniauth.state'] = @add_state if @add_state\\n    settings\\n  end\\n\\n  def add_state\\n    @add_state ||= SecureRandom.hex(24)\\n  end\\n</pre></code>\\n<p>Then have a look at the finish function in the javascript. Here we pass the state from GLOBAL_SETTINGS when we call '/users/auth/facebook/callback':</p>\\n<pre><code class=\\\"javascript\\\">\\nfinish: function(response){\\n    window.location.href = '/users/auth/facebook/callback?state='+ GLOBAL_SETTINGS.state;\\n}\\n</pre></code>\\n<p>Ideally, I would pass the state value when I call FB.Login but as far as I can tell from the Facebook documentation they don't provide\\na mechanism for passing parameters. It is possible to manually create the FB login popup in which case it would be possible to pass the state, but\\nthis solution was sufficient for our needs.</p>\",\"frontmatter\":{\"title\":\"Omniauth, Devise and Facebook Client Login Don't Play Nice\",\"date\":\"February 27, 2014\",\"imageUrl\":null,\"image\":null}}},\"pathContext\":{\"path\":\"/omniauth-devise-and-facebook-client-login-dont-play-nice\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---omniauth-devise-and-facebook-client-login-dont-play-nice-35cc1a60309d4d6e1de7.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Justin Ball\",\"author\":\"Justin Ball\"}},\"markdownRemark\":{\"id\":\"/Users/jbasdf/projects/justinball/src/posts/2014-02-27-omniauth-devise-and-facebook-client-login-dont-play-nice/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>I've had to use Facebook login inside an iframe twice now. Combine <a href=\\\"https://github.com/plataformatec/devise\\\">Devise</a>\\nwith <a href=\\\"https://github.com/intridea/omniauth\\\">omniauth</a> and <a href=\\\"https://github.com/mkdynamic/omniauth-facebook\\\">omniauth-facebook</a> and you have a\\npretty great user authentication system. Now try to login via Facebook inside an iframe and nothing will happen. If you check your Javascript console you'll see a error\\nthat looks something like this:</p>\\n<blockquote>\\n  Refused to display 'https://www.facebook.com/login.php?skip_api_login=1&api_key=asdfasdf%23_%3D_&display=page' in a frame because it set 'X-Frame-Options' to 'DENY'.\\n</blockquote>\\n<p>Facebook won't render their UI inside of an iframe. A lot of sites do that these days. However, you can use the Facebook Javascript client and everything will\\njust work - sort of. Omniauth-facebook documents a <a href=\\\"https://github.com/mkdynamic/omniauth-facebook#client-side-flow\\\">Client side flow</a> which looks like the\\nperfect solution to our problem but as I've learned it's not rainbows and unicorns.</p>\\n<p>If you do follow the advice provided by the documentation you'll spend hours saying things to your computer that you will regret. You'll feel depressed because you\\nfollowed the documentation and yet request.env[\\\"omniauth.auth\\\"] will be nil no mater what you do.</p>\\n<p>There are two github threads related to this problem: <a href=\\\"https://github.com/mkdynamic/omniauth-facebook/issues/73\\\">https://github.com/mkdynamic/omniauth-facebook/issues/73</a>\\nand <a href=\\\"https://github.com/intridea/omniauth-oauth2/issues/31\\\">https://github.com/intridea/omniauth-oauth2/issues/31</a> and a number of Stack Overflow questions\\n<a href=\\\"http://stackoverflow.com/questions/10320320/facebook-javascript-sdk-and-omniauth/22082218#22082218\\\">including this one that I tried to answer</a> since way\\nmore people will find it on Stack Overflow than here.</p>\\n<h3>Some Tips Before We Step In the Deep Stuff</h3>\\n<p>If you're debugging through this problem the first thing you might try is using a domain like lvh.me to access your local machine (it resolves to 127.0.0.1). Chrome\\nhas issues writing to localhost and it's possible that the Facebook cookie you need is not being properly written.</p>\\n<p>Right now would be a good time to check to make sure you don't accidently do the Oauth dance twice. This bit me. We have a link on the page with the id 'facebook_connect'.\\nIt just so happens that the href of that link is '/users/auth/facebook' which means it will initiate the Oauth dance using Omniauth. We only want to talk to Facebook once\\nso be sure to call e.preventDefault() or else you will keep wondering why you get two server calls:</p>\\n<pre><code class=\\\"javascript\\\">\\n$('#facebook_connect').on('click', function(e){\\n  e.preventDefault(); // Stop the request right here.\\n  Facebook.login();\\n});\\n</pre></code>\\n<p>The next thing you'll want to verify is that you are telling Facebook to write a cookie.</p>\\n<pre><code class=\\\"javascript\\\">\\nFB.init({\\n  appId      : GLOBAL_SETTINGS.FBappId,\\n  status     : false, // don't check login status\\n  cookie     : true, // enable cookies to allow the server to access the session\\n  xfbml      : true  // parse XFBML\\n});\\n</pre></code>\\n<h3>Before We Start</h3>\\nIf you just want to see how to do the Facebook OAuth dance client side below is the code I use to handle Facebook logins:\\n<script src=\\\"https://gist.github.com/jbasdf/9262863.js\\\"></script>\\n<h3>The Problem</h3>\\nI'm guessing you're still running into problems. The source of the issue is the callback_phase method inside the omniauth-oauth2 gem:\\n<pre><code class=\\\"ruby\\\">\\nif !options.provider_ignores_state && (request.params['state'].to_s.empty? || request.params['state'] != session.delete('omniauth.state'))\\n   raise CallbackError.new(nil, :csrf_detected)\\nend\\n</pre></code>\\n<p>request.params['state'] and session['omniauth.state'] are both nil so the condition fails and a CallbackError exception is raised. This is due\\nto the fact that we initiated the Facebook OAuth dance via FB.Login rather than using Omniauth to initiate the dance. Omniauth sets a state variable in the session\\nand then passes that as a state variable to Facebook like this:</p>\\n<pre><code class=\\\"ruby\\\">\\nsession['omniauth.state'] = SecureRandom.hex(24)\\n</pre></code>\\n<p>You can see above that the omniauth-oauth2 gem checks to make sure the state passed back from Facebook matches the one it saved into the session before\\nthe dance started.</p>\\n<p>Sucks for the client side process.</p>\\n<h3>Solution 1 - Cheap and Easy but Not So Secure</h3>\\nOne solution is to set provider_ignores_state to true which circumvents the condition:\\n<pre><code class=\\\"ruby\\\">\\nconfig.omniauth :facebook, ENV['FACEBOOK_APP_ID'], ENV['FACEBOOK_APP_SECRET'], {\\n  strategy_class: OmniAuth::Strategies::Facebook,\\n  provider_ignores_state: true,\\n}\\n</pre></code>\\n<p>That solution isn't especially secure since it can leave you open to csrf attacks.</p>\\n<h3>Solution 2 - More Code Solves Everything</h3>\\nMore code isn't usually a great way to solve your problems, but you can always create your own handler and parse the Facebook cookies yourself like this:\\n<pre><code class=\\\"ruby\\\">\\ndef handle_facebook_connect\\n    @provider = 'facebook'\\n    @oauth = Koala::Facebook::OAuth.new(ENV[\\\"FACEBOOK_ID\\\"], ENV[\\\"FACEBOOK_SECRET\\\"])\\n    auth = @oauth.get_user_info_from_cookies(cookies)\\n\\n    # Get an extended access token\\n    new_auth = @oauth.exchange_access_token_info(auth['access_token'])\\n    auth['access_token'] = new_auth[\\\"access_token\\\"]\\n\\n    # Use the auth object to setup or recover your user. The following is\\n    # and example of how you might handle the response but your needs and application structure will vary.\\n    if authentication = Authentication.where(:uid => auth['user_id'], :provider => @provider).first\\n      user = authentication.user\\n      sign_in(user, :event => :authentication)\\n    end\\n\\n    # Redirect or respond with json\\n    respond_to do |format|\\n      format.html { redirect_to user }\\n      format.json { render json: user }\\n    end\\nend\\n</pre></code>\\n<p>Then you'll need to redirect to the 'handle<em>facebook</em>connect' method when you receive a connected response:</p>\\n<pre><code class=\\\"javascript\\\">\\nFB.Event.subscribe('auth.authResponseChange', function(response) {\\n  if(response.status === 'connected'){\\n    if(response.authResponse){\\n\\n      // Redirect to our new handler\\n      window.location = '/handle_facebook_connect';\\n\\n    }\\n  } else if (response.status === 'not_authorized'){\\n    Facebook.message(Facebook.authorize_message);\\n  } else {\\n    FB.login();\\n  }\\n });\\n\\n</pre></code>\\n<h3>Solution 3 - Fake It</h3>\\nIf nothing so far brings joy to your heart then we can also simulate what omniauth does with the state variable.\\n<p>I create a helper method that can be called where ever we need to use the client side Facebook login. We also have a global settings object\\nthat can be accessed by our Javascript on the client. Calling 'add_state' generates a secure value and passes it to the client.</p>\\n<pre><code class=\\\"ruby\\\">\\ndef global_settings\\n    settings = {\\n      FBappId: ENV[\\\"FACEBOOK_ID\\\"],\\n      application_name: ENV[\\\"APPLICATION_NAME\\\"]\\n    }\\n    settings[:state] = session['omniauth.state'] = @add_state if @add_state\\n    settings\\n  end\\n\\n  def add_state\\n    @add_state ||= SecureRandom.hex(24)\\n  end\\n</pre></code>\\n<p>Then have a look at the finish function in the javascript. Here we pass the state from GLOBAL_SETTINGS when we call '/users/auth/facebook/callback':</p>\\n<pre><code class=\\\"javascript\\\">\\nfinish: function(response){\\n    window.location.href = '/users/auth/facebook/callback?state='+ GLOBAL_SETTINGS.state;\\n}\\n</pre></code>\\n<p>Ideally, I would pass the state value when I call FB.Login but as far as I can tell from the Facebook documentation they don't provide\\na mechanism for passing parameters. It is possible to manually create the FB login popup in which case it would be possible to pass the state, but\\nthis solution was sufficient for our needs.</p>\",\"frontmatter\":{\"title\":\"Omniauth, Devise and Facebook Client Login Don't Play Nice\",\"date\":\"February 27, 2014\",\"imageUrl\":null,\"image\":null}}},\"pathContext\":{\"path\":\"/omniauth-devise-and-facebook-client-login-dont-play-nice\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/omniauth-devise-and-facebook-client-login-dont-play-nice.json\n// module id = 1343\n// module chunks = 31230866529606"],"sourceRoot":""}